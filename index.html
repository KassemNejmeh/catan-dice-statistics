<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Catan Dice (Fair) — Dice + Statistics</title>
  <style>
    :root{
      --bg:#0b1020; --card:#111a33; --text:#eef2ff; --muted:#b7c2ff;
      --accent:#7aa2ff; --shadow: 0 12px 30px rgba(0,0,0,.35);
      --danger:#ff7a7a;
      --theory:#ff3b3b; /* red theoretical marker */
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: radial-gradient(1200px 600px at 50% 0%, #17245a 0%, var(--bg) 55%, #070b14 100%);
      color:var(--text);
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:20px;
    }
    .app{
      width:min(980px, 100%);
      background: rgba(17,26,51,.75);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(122,162,255,.18);
      border-radius:24px;
      box-shadow: var(--shadow);
      padding:24px;
    }
    header{
      display:flex; gap:14px; align-items:flex-start; justify-content:space-between;
      flex-wrap:wrap; margin-bottom:18px;
    }
    h1{font-size: clamp(18px, 2.3vw, 26px); margin:0;}
    .subtitle{margin:6px 0 0; color:var(--muted); font-size:14px; line-height:1.35; max-width: 78ch;}

    .topbar{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:flex-end;
    }
    .tab{
      appearance:none;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
      color: var(--text);
      padding:10px 12px;
      border-radius:14px;
      cursor:pointer;
      font-weight:900;
    }
    .tab.active{
      border-color: rgba(122,162,255,.45);
      box-shadow: 0 10px 20px rgba(122,162,255,.12);
    }
    .pill{
      border:1px solid rgba(255,255,255,.12);
      padding:10px 12px;
      border-radius:14px;
      background: rgba(0,0,0,.18);
      color: var(--muted);
      font-size: 13px;
      font-weight:800;
    }

    .row{display:grid; grid-template-columns: 1fr; gap:18px;}
    @media (min-width: 760px){ .row{grid-template-columns: 1.3fr .7fr;} }

    .card{
      background: rgba(17,26,51,.85);
      border: 1px solid rgba(255,255,255,.08);
      border-radius:20px;
      padding:18px;
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
    }

    /* Dice page */
    .dice-area{
      display:flex; gap:16px; align-items:center; justify-content:center;
      flex-wrap:wrap; padding:10px 0 4px;
    }
    .die{
      width: 160px; height: 160px; border-radius: 26px;
      background: linear-gradient(180deg, #ffffff 0%, #f2f5ff 70%, #dde6ff 100%);
      color:#0c1226;
      position:relative;
      box-shadow: 0 14px 26px rgba(0,0,0,.35);
      border: 2px solid rgba(10,18,38,.12);
      display:flex; align-items:center; justify-content:center;
      user-select:none;
    }
    .die-face{ font-size: 112px; line-height: 1; }
    .die-label{
      position:absolute; bottom:10px; left:12px;
      font-size:13px; color: rgba(12,18,38,.7); font-weight:600;
    }

    .sum{text-align:center; margin-top:10px; font-size: clamp(18px, 2.2vw, 26px);}
    .sum strong{font-size: clamp(34px, 4.2vw, 54px); color: var(--accent); display:inline-block; min-width: 1.2em;}

    /* Main button under dice */
    .roll-area{
      display:flex;
      justify-content:center;
      margin-top:14px;
    }
    .roll-btn{
      appearance:none; border:none; cursor:pointer;
      padding:18px 22px; border-radius:18px;
      font-size:20px; font-weight:900; color:#071028;
      background: linear-gradient(180deg, #93b5ff 0%, #7aa2ff 55%, #5c86ff 100%);
      box-shadow: 0 16px 30px rgba(122,162,255,.25);
      transition: transform .08s ease, filter .08s ease, opacity .08s ease;
      width:min(360px, 100%);
    }
    .roll-btn:active{ transform: translateY(2px) scale(.99); filter:brightness(.98); }
    .roll-btn:disabled{ cursor:not-allowed; opacity:.7; }

    .small-actions{
      display:flex; gap:10px; flex-wrap:wrap; justify-content:space-between; align-items:center;
      margin-top:12px;
    }
    .toggle{display:flex; align-items:center; gap:10px; color:var(--muted); font-size:14px; user-select:none;}
    .toggle input{ transform: scale(1.2); }

    .banner{
      display:none;
      border-radius:18px;
      border: 1px solid rgba(255,122,122,.35);
      background: rgba(255,122,122,.10);
      padding:14px 14px;
      margin-top:14px;
    }
    .banner.show{ display:block; }
    .banner h2{ margin:0 0 6px; font-size:18px; color: #ffd2d2; }
    .banner p{ margin:0; color:#ffecec; line-height:1.35; font-size:14px; }

    .last3{
      margin-top:14px;
      border-radius:18px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.16);
      padding:12px 14px;
    }
    .last3 h3{
      margin:0 0 8px;
      font-size:14px;
      color: var(--muted);
      font-weight:900;
      letter-spacing:.2px;
      text-transform: uppercase;
    }
    .last3-list{
      list-style:none; margin:0; padding:0;
      display:grid; gap:8px; font-size:14px;
    }
    .last3-item{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding:8px 10px; border-radius:14px;
      border: 1px solid rgba(255,255,255,.08);
      background: rgba(17,26,51,.55);
    }
    .k{ color: var(--muted); font-weight:700; }
    .v{ font-weight:900; }

    .side-actions{
      display:flex; flex-direction:column; gap:12px;
    }
    .note{
      color:var(--muted);
      font-size:13px;
      line-height:1.35;
      margin:0;
    }
    .legend{
      display:flex;
      gap:14px;
      flex-wrap:wrap;
      margin-top:8px;
      color:var(--muted);
      font-size:13px;
      align-items:center;
    }
    .swatch{
      width:14px; height:10px; border-radius:3px; display:inline-block; margin-right:8px;
      border:1px solid rgba(255,255,255,.18);
      vertical-align:middle;
    }
    .danger-btn{
      appearance:none; border:none; cursor:pointer;
      padding:12px 14px; border-radius:16px;
      font-weight:900;
      color:#25080a;
      background: rgba(255,122,122,.92);
    }

    /* Statistics page */
    .stat-wrap{ display:grid; gap:14px; }
    canvas{
      width: 100%;
      height: 420px;
      border-radius:18px;
      border: 1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.12);
      display:block;
    }
    .meta{
      display:flex;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
      color: var(--muted);
      font-size: 13px;
      margin-top: 10px;
    }
    .table{
      margin-top:14px;
      width:100%;
      border-collapse: collapse;
      font-size: 14px;
    }
    .table th, .table td{
      padding:10px 10px;
      border-bottom: 1px solid rgba(255,255,255,.08);
      text-align:right;
    }
    .table th:first-child, .table td:first-child{ text-align:left; }
    .table th{ color: var(--muted); font-weight:900; text-transform:uppercase; letter-spacing:.2px; font-size:12px; }

    /* Page switching */
    .page{ display:none; }
    .page.active{ display:block; }
  </style>
</head>

<body>
  <div class="app">
    <header>
      <div>
        <h1>Catan Dice (2d6) — Fair</h1>
        <p class="subtitle">
          Statistics auto-initializes with 1500 silent rolls (not shown on the dice page). Statistics always uses the last 1500 results.
          The red marker on each bar is the theoretical expected count for that sum.
        </p>
      </div>
      <div class="topbar">
        <button class="tab active" id="tabDice" type="button">Dice</button>
        <button class="tab" id="tabStats" type="button">Statistics</button>
        <div class="pill" id="rngPill">RNG: Web Crypto</div>
      </div>
    </header>

    <!-- DICE PAGE -->
    <section class="page active" id="pageDice" aria-label="Dice page">
      <div class="row">
        <div class="card">
          <div class="dice-area" aria-live="polite">
            <div class="die" id="die1" role="img" aria-label="Die 1 shows 1">
              <span class="die-face" id="die1Face">⚀</span>
              <div class="die-label">Die 1</div>
            </div>
            <div class="die" id="die2" role="img" aria-label="Die 2 shows 1">
              <span class="die-face" id="die2Face">⚀</span>
              <div class="die-label">Die 2</div>
            </div>
          </div>

          <div class="sum">Sum: <strong id="sum">2</strong></div>

          <div class="roll-area">
            <button class="roll-btn" id="rollBtn">ROLL DICE</button>
          </div>

          <div class="small-actions">
            <label class="toggle">
              <input type="checkbox" id="soundToggle" checked />
              Sound
            </label>
            <label class="toggle">
              <input type="checkbox" id="animateToggle" checked />
              Animation
            </label>
          </div>

          <div class="banner" id="sevenBanner" role="alert">
            <h2>Rolled a 7 — Robber rule</h2>
            <p>
              If you have more than 7 cards, discard half (rounded down),
              then move the robber and steal 1 card from an adjacent player.
            </p>
          </div>

          <div class="last3" id="last3Box">
            <h3>Last 3 real results</h3>
            <ul class="last3-list" id="last3List"></ul>
          </div>

          <div class="meta">
            <div id="countInfoDice">Real rolls: 0</div>
            <div id="lastInfoDice">Last real roll: —</div>
          </div>
        </div>

        <div class="card side-actions">
          <p class="note">
            Statistics uses last 1500 results (seeded once + your real rolls). The dice page shows only your real rolls.
          </p>
          <button class="danger-btn" id="clearHistoryBtn">Clear real + stats history</button>
        </div>
      </div>
    </section>

    <!-- STATS PAGE -->
    <section class="page" id="pageStats" aria-label="Statistics page">
      <div class="card stat-wrap">
        <canvas id="chart" width="980" height="420" aria-label="Statistics chart" role="img"></canvas>

        <div class="legend">
          <span><span class="swatch" style="background: rgba(122,162,255,0.85);"></span>Observed (last 1500)</span>
          <span><span class="swatch" style="background: var(--theory);"></span>Theoretical expected</span>
        </div>

        <div class="meta">
          <div id="countInfoStats">Stats rolls: 0 / 1500</div>
          <div id="lastInfoStats">Last stats roll: —</div>
        </div>

        <table class="table" aria-label="Frequency table">
          <thead>
            <tr>
              <th>Sum</th>
              <th>Observed</th>
              <th>Theoretical</th>
              <th>Observed %</th>
              <th>Theoretical %</th>
            </tr>
          </thead>
          <tbody id="freqBody"></tbody>
        </table>
      </div>
    </section>
  </div>

<script>
(() => {
  "use strict";

  // ----- constants -----
  const faces = ["", "⚀","⚁","⚂","⚃","⚄","⚅"];

  const MAX_STATS = 1500;

  // Separate histories:
  // - REAL: shown on main page ("last 3 real results")
  // - STATS: used for statistics; auto-seeded once to 1500 silent rolls
  const KEY_REAL  = "catanDice.realRolls.v2";   // array of {t, d1, d2, sum}
  const KEY_STATS = "catanDice.statsRolls.v2";  // array of {t, d1, d2, sum}
  const KEY_SEEDED = "catanDice.statsSeeded.v2"; // "1" when seeded

  // Theoretical weights for sums 2..12 (out of 36)
  const THEORY_W = {2:1,3:2,4:3,5:4,6:5,7:6,8:5,9:4,10:3,11:2,12:1};

  // ----- elements: tabs/pages -----
  const tabDice = document.getElementById("tabDice");
  const tabStats = document.getElementById("tabStats");
  const pageDice = document.getElementById("pageDice");
  const pageStats = document.getElementById("pageStats");

  // ----- elements: dice UI -----
  const die1El = document.getElementById("die1");
  const die2El = document.getElementById("die2");
  const die1Face = document.getElementById("die1Face");
  const die2Face = document.getElementById("die2Face");
  const sumEl = document.getElementById("sum");
  const sevenBannerEl = document.getElementById("sevenBanner");

  const last3ListEl = document.getElementById("last3List");
  const countInfoDiceEl = document.getElementById("countInfoDice");
  const lastInfoDiceEl = document.getElementById("lastInfoDice");

  const rollBtn = document.getElementById("rollBtn");
  const soundToggle = document.getElementById("soundToggle");
  const animateToggle = document.getElementById("animateToggle");
  const clearHistoryBtn = document.getElementById("clearHistoryBtn");

  // ----- elements: stats UI -----
  const canvas = document.getElementById("chart");
  const ctx = canvas.getContext("2d");
  const freqBodyEl = document.getElementById("freqBody");
  const countInfoStatsEl = document.getElementById("countInfoStats");
  const lastInfoStatsEl = document.getElementById("lastInfoStats");

  // ----- state -----
  let isRolling = false;
  let animTimer = null;

  // ----- helpers: fair RNG (rejection sampling) -----
  function cryptoRandomInt(min, max) {
    const range = max - min + 1;
    const maxUint32 = 0xFFFFFFFF;
    const limit = Math.floor((maxUint32 + 1) / range) * range;

    const buf = new Uint32Array(1);
    while (true) {
      crypto.getRandomValues(buf);
      const x = buf[0];
      if (x < limit) return min + (x % range);
    }
  }

  // ----- helpers: storage -----
  function load(key) {
    try {
      const raw = localStorage.getItem(key);
      if (!raw) return [];
      const data = JSON.parse(raw);
      if (!Array.isArray(data)) return [];
      return data
        .filter(r => r && Number.isInteger(r.d1) && Number.isInteger(r.d2) && Number.isInteger(r.sum))
        .filter(r => r.sum >= 2 && r.sum <= 12);
    } catch {
      return [];
    }
  }

  function save(key, arr, maxLen) {
    const out = (typeof maxLen === "number") ? arr.slice(-maxLen) : arr;
    localStorage.setItem(key, JSON.stringify(out));
  }

  function addToReal(d1, d2) {
    const arr = load(KEY_REAL);
    arr.push({ t: Date.now(), d1, d2, sum: d1 + d2 });
    save(KEY_REAL, arr); // no limit required for real; keep it simple
    return arr;
  }

  function addToStats(d1, d2) {
    const arr = load(KEY_STATS);
    arr.push({ t: Date.now(), d1, d2, sum: d1 + d2 });
    save(KEY_STATS, arr, MAX_STATS);
    return arr.slice(-MAX_STATS);
  }

  // Seed stats once (silent rolls) to exactly 1500 results
  function seedStatsIfNeeded() {
    const seeded = localStorage.getItem(KEY_SEEDED) === "1";
    const stats = load(KEY_STATS);
    if (seeded && stats.length > 0) return;

    // Build 1500 silent rolls into KEY_STATS
    const seededArr = [];
    for (let i = 0; i < MAX_STATS; i++) {
      const d1 = cryptoRandomInt(1, 6);
      const d2 = cryptoRandomInt(1, 6);
      seededArr.push({ t: Date.now() - (MAX_STATS - i) * 10, d1, d2, sum: d1 + d2 });
    }
    save(KEY_STATS, seededArr, MAX_STATS);
    localStorage.setItem(KEY_SEEDED, "1");
  }

  // ----- helpers: UI -----
  function setDie(faceEl, dieEl, value, labelPrefix) {
    faceEl.textContent = faces[value];
    dieEl.setAttribute("aria-label", `${labelPrefix} shows ${value}`);
  }

  function showSevenBanner(show) {
    sevenBannerEl.classList.toggle("show", !!show);
  }

  function clearAnimation() {
    if (animTimer !== null) {
      clearInterval(animTimer);
      animTimer = null;
    }
  }

  function formatTime(ts) {
    try {
      const d = new Date(ts);
      return d.toLocaleString([], {year:"numeric", month:"2-digit", day:"2-digit", hour:"2-digit", minute:"2-digit", second:"2-digit"});
    } catch {
      return "";
    }
  }

  // ----- main page: last 3 real results -----
  function renderLast3Real() {
    const real = load(KEY_REAL);
    const last3 = real.slice(-3).reverse();

    last3ListEl.innerHTML = "";
    if (last3.length === 0) {
      const li = document.createElement("li");
      li.className = "last3-item";
      li.innerHTML = `<span class="k">No real rolls yet</span><span class="v">—</span>`;
      last3ListEl.appendChild(li);
      return;
    }

    for (const r of last3) {
      const li = document.createElement("li");
      li.className = "last3-item";
      li.innerHTML =
        `<span class="k">${formatTime(r.t)} — ${r.d1} + ${r.d2}</span>` +
        `<span class="v">= ${r.sum}</span>`;
      last3ListEl.appendChild(li);
    }
  }

  function syncDiceFromReal() {
    const real = load(KEY_REAL);
    const total = real.length;

    countInfoDiceEl.textContent = `Real rolls: ${total}`;
    if (total > 0) {
      const last = real[total - 1];
      lastInfoDiceEl.textContent = `Last real roll: ${last.d1} + ${last.d2} = ${last.sum} at ${formatTime(last.t)}`;
      setDie(die1Face, die1El, last.d1, "Die 1");
      setDie(die2Face, die2El, last.d2, "Die 2");
      sumEl.textContent = String(last.sum);
      showSevenBanner(last.sum === 7);
    } else {
      lastInfoDiceEl.textContent = "Last real roll: —";
      setDie(die1Face, die1El, 1, "Die 1");
      setDie(die2Face, die2El, 1, "Die 2");
      sumEl.textContent = "2";
      showSevenBanner(false);
    }
  }

  // ----- sound (generated) -----
  let audioCtx = null;
  function getAudioContext() {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    return audioCtx;
  }

  function playDiceSound() {
    if (!soundToggle.checked) return;

    const ctxA = getAudioContext();
    if (ctxA.state === "suspended") ctxA.resume().catch(() => {});

    const now = ctxA.currentTime;
    const duration = 0.45;

    const bufferSize = Math.floor(ctxA.sampleRate * duration);
    const noiseBuffer = ctxA.createBuffer(1, bufferSize, ctxA.sampleRate);
    const output = noiseBuffer.getChannelData(0);

    for (let i = 0; i < bufferSize; i++) {
      const t = i / bufferSize;
      const env = Math.pow(1 - t, 2.2);
      output[i] = (Math.random() * 2 - 1) * env;
    }

    const noise = ctxA.createBufferSource();
    noise.buffer = noiseBuffer;

    const bandpass = ctxA.createBiquadFilter();
    bandpass.type = "bandpass";
    bandpass.frequency.setValueAtTime(900, now);
    bandpass.Q.setValueAtTime(0.9, now);

    const gain = ctxA.createGain();
    gain.gain.setValueAtTime(0.0001, now);
    gain.gain.exponentialRampToValueAtTime(0.55, now + 0.02);
    gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);

    noise.connect(bandpass).connect(gain).connect(ctxA.destination);
    noise.start(now);
    noise.stop(now + duration);

    for (let k = 0; k < 4; k++) {
      const tickTime = now + 0.06 + k * 0.07 + (Math.random() * 0.015);
      const osc = ctxA.createOscillator();
      const tickGain = ctxA.createGain();
      osc.type = "triangle";
      osc.frequency.setValueAtTime(160 + Math.random() * 260, tickTime);
      tickGain.gain.setValueAtTime(0.0001, tickTime);
      tickGain.gain.exponentialRampToValueAtTime(0.12, tickTime + 0.005);
      tickGain.gain.exponentialRampToValueAtTime(0.0001, tickTime + 0.03);
      osc.connect(tickGain).connect(ctxA.destination);
      osc.start(tickTime);
      osc.stop(tickTime + 0.04);
    }
  }

  // ----- rolling logic -----
  function rollDice() {
    if (isRolling) return;
    isRolling = true;
    rollBtn.disabled = true;

    playDiceSound();
    clearAnimation();

    const finish = () => {
      const d1 = cryptoRandomInt(1, 6);
      const d2 = cryptoRandomInt(1, 6);

      setDie(die1Face, die1El, d1, "Die 1");
      setDie(die2Face, die2El, d2, "Die 2");

      const s = d1 + d2;
      sumEl.textContent = String(s);
      showSevenBanner(s === 7);

      // Add to both histories:
      addToReal(d1, d2);
      addToStats(d1, d2);

      renderLast3Real();
      syncDiceFromReal();
      renderStats(); // keep stats ready

      isRolling = false;
      rollBtn.disabled = false;
    };

    if (!animateToggle.checked) {
      finish();
      return;
    }

    let frames = 10;
    animTimer = setInterval(() => {
      const a = cryptoRandomInt(1, 6);
      const b = cryptoRandomInt(1, 6);
      setDie(die1Face, die1El, a, "Die 1");
      setDie(die2Face, die2El, b, "Die 2");

      frames--;
      if (frames <= 0) {
        clearAnimation();
        finish();
      }
    }, 45);
  }

  // ----- statistics -----
  function computeObservedFreq(statsRolls) {
    const freq = {};
    for (let s = 2; s <= 12; s++) freq[s] = 0;
    for (const r of statsRolls) freq[r.sum] += 1;
    return freq;
  }

  function computeTheoreticalCounts(total) {
    const theo = {};
    for (let s = 2; s <= 12; s++) {
      theo[s] = total * (THEORY_W[s] / 36);
    }
    return theo;
  }

  function clearCanvas() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  }

  function drawChart(observed, theoretical, total) {
    clearCanvas();

    const W = canvas.width;
    const H = canvas.height;

    const padL = 60, padR = 20, padT = 20, padB = 55;
    const plotW = W - padL - padR;
    const plotH = H - padT - padB;

    // background
    ctx.fillStyle = "rgba(0,0,0,0.10)";
    ctx.fillRect(0, 0, W, H);

    // axes
    ctx.strokeStyle = "rgba(255,255,255,0.22)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(padL, padT);
    ctx.lineTo(padL, padT + plotH);
    ctx.lineTo(padL + plotW, padT + plotH);
    ctx.stroke();

    // Scale to max of observed vs theoretical so red markers always visible
    const maxObs = Math.max(1, ...Object.values(observed));
    const maxTheo = Math.max(1, ...Object.values(theoretical));
    const maxCount = Math.max(maxObs, maxTheo);

    // y grid/ticks
    ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    const yTicks = 5;
    for (let i = 0; i <= yTicks; i++) {
      const v = Math.round((maxCount * i) / yTicks);
      const y = padT + plotH - (plotH * i / yTicks);

      ctx.strokeStyle = "rgba(255,255,255,0.10)";
      ctx.beginPath();
      ctx.moveTo(padL, y);
      ctx.lineTo(padL + plotW, y);
      ctx.stroke();

      ctx.fillStyle = "rgba(255,255,255,0.70)";
      ctx.textAlign = "right";
      ctx.textBaseline = "middle";
      ctx.fillText(String(v), padL - 10, y);
    }

    // bars 2..12
    const sums = [];
    for (let s = 2; s <= 12; s++) sums.push(s);

    const gap = 10;
    const barW = (plotW - gap * (sums.length - 1)) / sums.length;

    for (let i = 0; i < sums.length; i++) {
      const s = sums[i];

      const obs = observed[s];
      const theo = theoretical[s];

      const obsH = (obs / maxCount) * plotH;
      const obsX = padL + i * (barW + gap);
      const obsY = padT + plotH - obsH;

      // observed bar (blue)
      ctx.fillStyle = "rgba(122,162,255,0.85)";
      ctx.fillRect(obsX, obsY, barW, obsH);

      ctx.strokeStyle = "rgba(255,255,255,0.18)";
      ctx.strokeRect(obsX, obsY, barW, obsH);

      // theoretical marker (red horizontal line at expected height)
      const theoY = padT + plotH - ((theo / maxCount) * plotH);
      ctx.strokeStyle = "rgba(255,59,59,0.95)";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(obsX, theoY);
      ctx.lineTo(obsX + barW, theoY);
      ctx.stroke();
      ctx.lineWidth = 1;

      // x labels
      ctx.fillStyle = "rgba(255,255,255,0.85)";
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      ctx.fillText(String(s), obsX + barW/2, padT + plotH + 10);

      // observed count on top
      ctx.fillStyle = "rgba(255,255,255,0.90)";
      ctx.textAlign = "center";
      ctx.textBaseline = "bottom";
      ctx.fillText(String(obs), obsX + barW/2, obsY - 6);
    }

    // title
    ctx.fillStyle = "rgba(255,255,255,0.85)";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    ctx.font = "14px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText(`Observed vs theoretical (n=${total})`, padL, padT);
  }

  function renderTable(observed, theoretical, total) {
    freqBodyEl.innerHTML = "";
    for (let s = 2; s <= 12; s++) {
      const obs = observed[s];
      const theo = theoretical[s];
      const obsPct = total > 0 ? (100 * obs / total) : 0;
      const theoPct = (THEORY_W[s] / 36) * 100;

      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td style="text-align:left; font-weight:900;">${s}</td>
        <td>${obs}</td>
        <td>${theo.toFixed(1)}</td>
        <td>${obsPct.toFixed(2)}%</td>
        <td>${theoPct.toFixed(2)}%</td>
      `;
      freqBodyEl.appendChild(tr);
    }
  }

  function renderStats() {
    const stats = load(KEY_STATS).slice(-MAX_STATS);
    const total = stats.length;
    const observed = computeObservedFreq(stats);
    const theoretical = computeTheoreticalCounts(total);

    countInfoStatsEl.textContent = `Stats rolls: ${total} / ${MAX_STATS}`;
    if (total > 0) {
      const last = stats[total - 1];
      lastInfoStatsEl.textContent = `Last stats roll: ${last.d1} + ${last.d2} = ${last.sum} at ${formatTime(last.t)}`;
    } else {
      lastInfoStatsEl.textContent = "Last stats roll: —";
    }

    drawChart(observed, theoretical, total);
    renderTable(observed, theoretical, total);
  }

  // ----- page switching -----
  function showPage(which) {
    const isDice = (which === "dice");
    pageDice.classList.toggle("active", isDice);
    pageStats.classList.toggle("active", !isDice);
    tabDice.classList.toggle("active", isDice);
    tabStats.classList.toggle("active", !isDice);

    if (!isDice) renderStats();
  }

  tabDice.addEventListener("click", () => showPage("dice"));
  tabStats.addEventListener("click", () => showPage("stats"));

  // ----- events -----
  rollBtn.addEventListener("click", rollDice);

  document.addEventListener("keydown", (e) => {
    if (e.code === "Space" || e.code === "Enter") {
      if (!pageDice.classList.contains("active")) return;
      e.preventDefault();
      rollDice();
    }
  });

  clearHistoryBtn.addEventListener("click", () => {
    localStorage.removeItem(KEY_REAL);
    localStorage.removeItem(KEY_STATS);
    localStorage.removeItem(KEY_SEEDED);

    clearAnimation();
    isRolling = false;
    rollBtn.disabled = false;

    setDie(die1Face, die1El, 1, "Die 1");
    setDie(die2Face, die2El, 1, "Die 2");
    sumEl.textContent = "2";
    showSevenBanner(false);

    // Re-seed stats immediately (silent)
    seedStatsIfNeeded();

    renderLast3Real();
    syncDiceFromReal();
    renderStats();
  });

  // ----- init -----
  seedStatsIfNeeded();      // silent 1500 rolls before first use (stats only)
  renderLast3Real();        // real only
  syncDiceFromReal();       // real only
  renderStats();            // stats page ready
})();
</script>
</body>
</html>
